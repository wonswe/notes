### 컴퓨터와 자료 (1)

**컴퓨터**: 프로그램이 가능한 데이터 처리기 (programmable data processor)
- 장점: *신속*, *정확*, *자동*, *대용량*
- 데이터의 입력 (input) -> 처리 (process) -> 결과 출력 (output)

**프로그램**: 컴퓨터가 데이터를 어떻게 처리(조작)할지를 알려주는 일련의 명령어의 집합
- 컴퓨터에서 처리 가능한 작업의 유형과 연산의 집합을 결정

**컴퓨터과학이란?**
- 데이터의 획득, 표현, 처리, 저장, 통신, 접근을 위한 방법들의 실행 가능성, 구조화, 표현, 기계화에 관련된 내용을 다루는 학문 분야
- *컴퓨터*, *데이터*, *프로그램*, *알고리즘* 분야의 연구를 통해 효율적인 자료 처리를 위한 제반 기술과 방법들을 제공하기 위한 학문
- 알고리즘과 관련된 이슈를 다루는 학문 -> 컴퓨터과학의 모든 관련 분야를 “알고리즘” 중심으로 이해 가능
- 컴퓨터를 활용한 문제 해결에 대한 학문

**컴퓨터공학** - 가격 대비 성능 특성이 가장 좋은 컴퓨터 엔진을 만들기 위해 하드웨어와 소프트웨어 요소를 조립하는 방법에 중점을 둠

**컴퓨터과학** - 현재의 기술에 덜 의존적인 방식으로 주어진 문제에 대한 해결책이 효율적이고 실현 가능성에 보다 초점을 둠

컴퓨터 시스템의 **4가지 구성요소**
1. *하드웨어* - 기계를 구성하고 있는 모든 물리적 *기계장치* 및 *전자장치*
   ![[하드웨어의 구성.png|400]]
	- 핵심 장치
		1. *중앙처리장치 CPU* - Central Processing Unit
			1. 산술논리연산장치 Arithmetic and Logic Unit - 산술 연산 & 논리 연산의 수행을 통해 직접적인 데이터 처리가 이루어지는 장치
			2. 제어장치 Control Unit - 컴퓨터의 기억장치, 산술논리연산장치, 입출력장치의 동작을 제어하는 장치
		2. *기억장치* 
			1. 주기억장치 - 처리할 입력 데이터, 처리를 담당하는 프로그램, 중간 결과, 출력할 데이터
			2. 보조기억장치
		3. *입력장치* - 키보드, 마우스, 마이크, 카메라 등 [보조기억장치 (디스크)]
		4. *출력장치*  - 모니터, 프린터, 스피커 등 [보조기억장치 (디스크)]
    ![[하드웨어 요소 간의 통신.png|600]]

2. *소프트웨어* - 모든 프로그램을 총체적으로 표현하는 것
	- 컴퓨터가 데이터를 어떻게 처리할 것인가를 규정하는 명령어들의 나열
		1. **시스템 소프트웨어** -  컴퓨터 자체의 작업 관리와 특정 기능의 수행을 통해 컴퓨터의 전체적인 운영을 담당한느 프로그램 (운영체제, 컴파일러, ...)
		2. **응용 소프트웨어** - 사용자가 요구하는 작업을 직접적으로 수행하는 프로그램 (워드프로세서, 그래픽 프로그램, 웹 브라우저, ...)

3. *데이터* - 컴퓨터가 처리할 대상으로 컴퓨터 내부에서 **비트 패턴으로 변환**되어 처리되고, 적절한 **변환 과정을 다시 거쳐 출력**됨


4. *사용자*operator- 컴퓨터가 데이터를 처리하는 전반적인 과정에 다양하고 적극적인 형태로 사람이 개입이 필요

**폰 노이만 모델** - 컴퓨터의 *내부 구조*와 *처리 과정*을 정의한 모델
- 모든 컴퓨터는 폰 노이만 모델에 기반을 둠
- *4개의 서브시스템*으로 구성
	1. 산술논리연산장치
	2. 제어장치
	3. 기억장치
	4. 입출력장치
- *내장 프로그램*  stored program 방식
	- 데이터와 함께 실행될 프로그램은 *메모리에* 저장되어야 함
	- 데이터와 프로그램이 같은 메모리에 저장된다는 것은 동일한 형식 ("비트 패턴")으로 저장된다는 의미를 내포 -
	- "프로그램은 유한 개의 명령어의 나열" - 기본 명령어의 집합을 *미리* 정의하고, 이들의 유한개의 조합으로 원하는 프로그램을 구성
	- 제어장치가 메모리에서 한 번에 하나씩 명령어를 가져와서*fetch* 해석하고*decode* 산술논리연선장치가 실행함*execute*
	- 명령어들의 재사용성 good ~

### 컴퓨터와 자료 (2)

1. **데이터와 정보**  
    - I=P(D) → “*데이터 D*를 대상으로 *처리기 P*에서 처리해서 얻은 *결과가 정보 I*이다.”  
    - *데이터* → 현실 세계로부터 관찰이나 측정을 통해 단순히 얻어지는 사실이나 값  
    - *정보* → 어떤 상황에 대해 *적절한 의사결정*을 수행할 수 있게 하는 지식  
    - *데이터 처리(“정보처리”)* → 데이터를 정보로 가공하고 변환하는 일련의 과정  

     ![[데이터와 정보의 관계.png|400]]
    - 모든 데이터는 유형에 무관하게 *비트 패턴*이라는 일관된 방식으로 표현  
		=> 메모리에 저장된 데이터 유형에 맞는 해석과 처리가 필요 
		(입출력장치나 프로그램의 책임/역할)
	
    - *데이터의 표현 단위* → 비트, 바이트, KB, MB, GB, TB, PB, EB, ZB, YB  
	    - 비트 binary digit - 0 or 1
	    - 바이트 byte - 길이가 8개인 비트 패턴
		![[데이터의 표현 단위.png|600]]

    - 워드word → *컴퓨터 연산의 기본 단위가 되는 정보의 양*: 보통 32비트, 64비트  

2. **진법** - 수를 세는 방법 또는 단위
	- r진법 → 0, 1, …, (r-1)까지의 숫자만을 사용해서 수를 표현하는 방식 또는 단위  
	- *2진법*, *8진법,* *10진법*, *16진법* 간의 변환이 필요    
     ![[r진법.png|400]]
     ![[r진법표기예시.png|400]]
	- 2진수/8진수/16진수를 10진수로 변환 
	  → 각 위치에서의 숫자값과 **해당 위치에서의 가중치(자릿값)를 곱한 후**, **그 결과들을 모두 더함**  
      ![[2진수를10진수로.png|500]]
      ![[8:16진수를10진수로.png|500]]

	- **10진수를 r진수로 변환** → 정수 부분과 소수 부분을 나눠서 각각의 방법으로 변환한 후, 그 결과를 단순히 연결해서 표현함 → 정수 부분에 대해서는 나눗셈을 적용한 후 나머지를 결과로 활용, 소수 부분에 대해서는 곱셈을 적용한 후 정수 부분을 결과로 활용  
	  ![[10진수를r진수로.png|500]]
      ![[10진수를r진수로_알고리즘.png|500]]
      ![[10진수를r진수로_예시.png|500]]
      ![[10진수를r진수로_소수 부분_알고리즘.png|500]]
	  ![[10진수를r진수로_소수 부분_예1.png|500]]
	  ![[10진수를r진수로_소수 부분_예2.png|500]]

      ![[컴퓨터에서의 실수는 근사치.png|500]]
      위에서 볼 수 있듯, 컴퓨터에서 나타내는 실수는 *근사치*다 
      ![[r진수 간의 변환.png|500]]
  
	- 2진수와 8진수/16진수의 관계 → 2진수의 3자릿수 = 8진수의 1자릿수, 2진수의 4자릿수 = 16진수의 1자릿수  
    

3. **정수 표현**  
    - 정수 표현 방법의 종류
		1. *부호 없는* 정수 → 부호 비트가 없다
			- 주어진 n비트 전체를 사용해서 정수(0~2^(n-1))를 표현  
			 ![[부호없는정수.png|400]]
		2. *부호 있는* 정수 → 최상위 1비트를 부호 비트로 사용
		    1. 부호화-크기 방식 → 음의 정수는 음수에 대한 절대값으로 표현  

		    2. 1의 보수 방식 → 부호 비트 사용. 음의 정수는 양의 정수 표현에 대해 **보수**(0→1, 1→0)를 취해서 표현    ![[부호있는정수예.png]]

		    3. 2의 보수 방식 → 부호 비트 사용. 음의 정수는 1의 보수 방식의 결과에 1을 더해서 표현  
			    ![[부호있는정수예.png]]
				![[정수표현의방법비교.png]]

4. **실수 표현**  

	![[실수표현예.png|400]]
    - 과학적 표기법을 활용한 부동소수점 방식으로 표현 
    - 표현 형식 → (-1)부호×가수×2지수 → “부호(1비트)+지수(m비트)+가수(n비트)”  

    - 지수의 표현  
    - **초과표기법** → 부동소수점의 *지수 부분*만을 위한 표기 방법 → 지수를 m비트로 표현하는 경우 두 개의 매직 넘버(2m-1, 2m-1-1) 중에서 하나를 사용  
	  ![[초과표기법예.png]]

    - 지수값을 저장하는 경우 → (지수값 + 매직 넘버)를 이진수로 표현/저장  
    - 저장된 지수값을 해석하는 경우 → (지수 부분의 이진수 값 - 매직 넘버)  

	- 가수를 표현할 때 표준화된 형식이 필요 → **정규화** → *소수점 바로 왼쪽에 오직 하나의 1만 있도록 소수점의 위치를 조정* → 가수값을 저장할 때는 소수점 이하 부분만 저장  
	  ![[정규화방법.png|400]]
	- 실수 표현의 에
     ![[실수표현의예.png]]
	  ![[IEEE부동소수점표기법.png]]
5. **문자 표현**  
    - 키보드로 입력되는 문자를 *내부적으로 2진수로 변환*하여 처리하기 위해서는 문자마다 유일한 코드를 부여할 수 있는 약속된 문자 체계가 필요  
    - 대표적인 문자 체계 → *ASCII (또는 확장된 ASCII)*, *유니코드*
- ASCII → American Standard Code for Information Interchange
	- 미국표준협회 (ANSI)
	- 7비트 코드 → 128개 (2^7)의 서로 다른 문자 표현
		- 확장된 아스키 Extended ASCII → 1비트 + 7비트
		- 패러티 parity 비트로 전송 중 에러가 없었는지 확인 가능
- 유니코드
	- 세계의 모든 문자를 컴퓨터에서 일관되게 표현하고 다룰 수 있도록 설계된 표준
- 기타 코드 체계
	- EBCDIC - Extended Binary Coded Decimal Interchange Code
		- IBM 개발, 8비트 코드 → 실제 사용되는 문자 코드는 128개
	- BCD - Binary Coded Decimal
		- 4비트로 구성된 10개의 코드로 10진수를 표현하는 방식 → '8421 코드'


### 자료구조(1)

추상화와 구조화 → 자료의 추상화와 구조화가 적절히 이루어지지 못하면 소프트웨어는
- 비효율적으로 개발
- 비효율적으로 수행
- 확장성의 문제
- 유지보수에 문제
... 등 생길 수 있음

**추상화** → 공통적인 개념을 이용하여 같은 종류의 다양한 객체를 정의하는 것 (수식, 프로그램 언어 등)

**자료(데이터)추상화** → 다양항 객체를 컴퓨터에서 표현하고 활용하기 위해 필요한 *데이터의 구조에 대해서 공통의 특징만을 뽑아 정의한 것* 

1. **자료구조** → 자료 사이의 논리적 관계를 컴퓨터나 프로그램이 보다 쉽게 이해하고 다룰 수 있도록 구성한 것 → *추상화를 통해 자료의 논리적 관계를 구조화한 것*
   ![[자료구조의 종류와 관계.png|600]]
	
2. **배열array**  → 같은 자료형을 갖는 여러 개의 데이터를 *하나의 변수*로 묶어놓은 데이터의 집합체이며,  각 원소를 구분하기 위해 *인덱스*(또는 첨자)와 *데이터 값*의 쌍으로 이루어짐  
	- 배열의 기억공간은 정적으로 할당, 선언문을 통해 정의
	- 각 원소에 대한 접근 시간은 인덱스를 통해 접근되기 때문에 모든 원소의 접근 시간은 동일함
	- 원소가 어느 위치에 저장되어 있느냐에 따라 차이가 발생하는 자료구조로는 리스트가 대표적인 예
	![[1차원배열주소계산.png|600]]
	- 배열의 원소들은 연속적인 기억장소에 저장되어 *순차적으로 저장*되기 때문에 배열의 시작주소와  각 자료형의 크기를 알면 i번째 원소의 주소를 알면, 직접 접근이 가능함  
	- 물리적 주소(메모리/RAM의 주소)와 논리적 주소(개발자가 정의한 주소 like 변수)가 일치(mapping되는) 하는 유일한 자료구조
     - 다차원 배열이 저장되는 방식으로는 열 우선 순서와 행 우선 순서가 있음
		![[2차원배열.png|400]]
	    - **2차원 배열 저장 순서** 
		    - 열 우선 순서 저장 → 첫 열에 있는 각 행의 원소를 차례대로 컴퓨터 메모리에 저장하고 다음 열로 이동하여 각 행에 있는 원소를 차례대로 컴퓨터 메모리에 저장하는 방법
		    - 행 우선 순서 저장 → 첫 행에 있는 각 행의 원소를 차례대로 컴퓨터 메모리에 저장하고 다음 행으로 이동하여 각 열에 있는 원소를 차례대로 컴퓨터 메모리에 저장하는 방법
        ![[3차원배열.png|400]]
		![[희소행렬의효율적표현.png|400]]

3. **리스트**
	- 선형 리스트 (linear list) → 순서 리스트 (ordered list)라고도 함
	- 1개 이상의 원소들이 순서를 가지고 구성됨
	- A = (a1, a2, ..., ai, an)과 같이 표시하며 ai는 i번째 원소를 나타내고, an의 n은 리스트의 크기가 된다 
	- ex. 요일 리스트: (월, 화, 수, 목, 금, 토, 일)
	- ex. 전쟁 리스트: ((임진왜란, 1592), (황산벌 전투, 660))
	- 선형 리스트와 1차원 배열은 순차적인 구조를 가지고 있으므로 1차원 배열로 간단하게 표현할 수 있음
	- 삽입시 순서를 그대로 유지하면서 해야 함 & 삭제시 원소들을 한 칸 씩 앞으로 이동시켜야 함, 등 등 삽입 & 삭제 시 데이터의 이동이 잦아지므로 비효율적이다

4. **연결 리스트**  → 노드들을 연결하여 구성하는 것으로, 한 노드는 **데이터 필드**와 **링크 필드**로 구성됨  
     - *단일 연결 리스트* : 링크 필드가 하나이고, 한 방향으로만 검색이 가능함  
     - *이중 연결 리스트* : 2개의 링크 필드를 사용해서 양방향(선행 노드 방향, 후행 노드 방향)의 검색이  가능함  
     - *원형 연결 리스트* : 마지막 노드의 링크 필드가 첫 번째 노드에 연결되어, 한 방향이지만 전체 연결 & 리스트를 원형으로 연결함
    
5. **스택** → 리스트의 *한쪽 끝에서만 삽입과 삭제가 이루어지*는 *선입후출*(FILO, First-In-Last-Out) 구조  
	- 스택 언더플로 → 삭제 연산을 수행할 때 발생함
		- 스택에 데이터가 존재하지 않으면 삭제가 일어나지 않는 현상
	- 스택 오버플로 → 삽입 연산을 수핼할 때 발생함
		- 스택을 위해 할당된 저장 공간을 초과해서 더 이상 데이터를 삽입할 수 없는 현상
	- pop연산과 push 연산이 가장 중요한 연산임
    
6. **큐** → 리스트의 한쪽 끝에서는 삽입, 다른 한쪽 끝에서는 삭제가 이루어지는 *선입선출(FIFO)* 구조  
	- 오버플로 → 삽입시 발생 & 큐를 위해 할당된 저장 공간을 초과해서 더 이상 데이터를 삽입할 수 없는 현상
	- 언더플로 → 삭제시 발생 & 큐에 데이터가 존재하지 않으면 삭제가 일어나지 않는 현상
	- insert 연산과 delete 연산이 가장 중요한 연산임
	- 만원 상태 → 데이터가 큐에 삽입됨에 따라 rear 변수 값이 증가하다가 n-1이 되면 더 이상 데이터가 삽입될 수 없는 상태가 됨, but 이 경우가 반드시 큐에 n개의 항목이 가득 차 있다는 것을 의미하지는 않는다. 큐가 가득 채워진 상태를 결정하기 위한 다른 방법이 필요!


### 자료구조(2)

1. 트리 → 노드와 가지로 구성되어 나무 뿌리 모양의 데이터의 계층 관계를 나타내는 자료구조  

     - **트리(tree)** : 데이터간의 관계를 나타내는 *비선형 자료구조*로서 노드(node)라고 불리는 부분과 노드를 연결하는 가지(branch, edge)로 구분됨  
	     - 노드node: 정보 항목
	     - 루트root: 빈 트리가 아닌 경우에 맨 꼭대기에 있는 하나의 노드
	     - 가지branch, edge: 노드를 연결하는 것
	     - 차수degree: 각 노드의 수
	     - 레벨: 루트 노드로부터의 거리
	     - 트리의 깊이/높이 depth/height: 레벨에서 가장 큰 값

	     - 조상(선조) 노드: 루트 노드로부터 어떤 노드 x까지의 경로(가지들의 모음) 상에 존재하는 모든 노드를 x의 조상 노드라고 한다
	     - 자손(후손) 노드: 어떤 노드 x에서 단말 노드까지의 경로 상에 존재하는 모든 노드를 자손 노드라고 함

		- 서브 트리 (subtree): 특정 노드를 루트 노드로 하고, 그 아래에 있는 연결된 구조의 트리
		- 숲 (forest): n개의 서브 트리를 가진 트리에서 루트 노드를 제거해서 얻을 수 있는 분리된 서브 트리의 집합

     - **잎 노드(leaf node)** : 단말 노드(terminal node)라고도 하며, 노드의 **차수가 0**인 노드  
     - **내부 노드(internal node)** : 비단말 노드(non-terminal node)라고도 하며, 루트 노드와 단말 노드를 제외한 나머지 노드  

     - **이진트리 (binary tree)** : 트리 중에서 차수가 2인 트리를 의미하고, 모든 노드의 차수는 최대 2를 넘지 않으며 모든 노드는 최대 2개의 서브 트리를 가짐  
	     - 왼쪽 노드와 오른쪽 노드에 '순서'의 의미를 부여함
	     - 이진 트리의 각 서브 트리는 다시 이진 트리가 됨
	- 이진 트리의 높이:
		- 최대 높이: N개의 노드를 가진 이진 트리의 높이를 계산으로 구할 수 있음
			- 최대 높이 → N으로 노드의 개수와 같음
		- 최소 높이: 모든 내부 노드가 최대 2개의 자식 노드를 갖는 경우로서 [log2N + 1]이 높이가 됨 

     - **이진트리의 순회** : 일정한 순서에 따라 트리에 있는 각 노드를 한 번씩 방문하는 것  

     - 이진트리의 종류:
		 - **포화이진트리** : 이진트리 중에서도 깊이가 k인 이진트리가 가질 수 있는 최대 노드의 개수(2^k -1)를  가진 이진트리 & 단말 노드의 개수가 (2^k -1)
			 - 각 레벨에서 빈자리가 없이 노드를 모두 가지고 있음
			 - 모든 내부 노드들은 2개의 자식 노드를 가짐

		 - **완전이진트리** : 트리의 최대 레벨이 k일 때, 레벨 k-1까지는 포화 이진트리를 형성하고, 레벨 k에서는 왼쪽부터 오른쪽으로 채워진 트리임
			 - 총 노드의 개수가 (2^(k+1) - 1)을 초과하지 않으면서, 포화 이진 트리의 노드 변호에 해당하는 *연속적인 번호*를 갖는 트리
				![[완전 이진 트리 예.png]]
		 - **경사이진트리** skewed binary tree: 한쪽 방향으로 치우친 트리
			 - 왼쪽 or 오른쪽

2. 트리 순회 → 일정한 순서에 따라 트리에 있는 각 노드를 한 번씩 방문하는 것 
	![[이진 트리 순회 연산 - 개념.png|500]]
	1. **전위 순회** →  DataLeftRight (전의 순회; preorder)
		- *루트 노드 방문* → 왼쪽 서브트리 방문 → 오른쪽 서브 트리 방문
	2. **중위 순회** → LeftDataRight (중위 순회; inorder)
		- 왼쪽 서브 트리 방문 → *루트 노드 방문* → 오른쪽 서브 트리 방문
	3. **후위 순회** → LeftRightData (후위 순회; postorder)
		- 왼쪽 서브 트리 방문 → 오른쪽 서브 트리 방문 → *루트 노드 방문* 
    
3. 그래프→ 정점들의 유한 집합과 정점들의 쌍을 연결하는 간선의 유한집합  
     - **그래프(graph)** →  정점(vertex)들의 *유한 집합 V*와 *두 개의 정점을 연결하는 간선*(edge)들의 유한 집합 E

     - **G=(V,E)**

     - 그래프의 종류
	     - **무방향 그래프(undirected graph)** →  간선이 방향성이 없는 간선으로 연결된 그래프  
		     - 한 정점의 차수 → 정점에 부수된 간선의 개수
	     - **방향 그래프(directed graph, digraph)** → 두 정점을 연결하는 간선이 방향성을 가지는 간선으로 연결된 그래프  
		     - 방향 그래프 정점의 차수는 진입 차수와 진출 차수로 나뉨
			     - 진입 차수 indegree → 다른 정점에서 해당 정점으로 향하는 간선의 개수
			     - 진출 사수 outdegree → 해당 정점에서 다른 정점으로 향하는 간선의 개수
		- 트리는 그래프의 특수한 형태로 봄 → 무뱡향 그래프에서 모든 정점이 서로 연결되어 있으면서 사이클이 존재하지 않는 그래프 → 트리

     - 그래프의 표현
		- 두 정점이 간선으로 직접 연결되어 있으면 두 정점은 인접해 있다고 하며, 해당 간선은 두 정점에 부수incident 되었다고 함
			- 인접adjacent → 정점 간의 관계
			- 부수incident → 정점과 간선의 관계
			- 경로path → 간선으로 연결된 정점들의 순차적 나열을 의미
				- 경로의 길이 → 경로에 포함된 간선의 개수
				- 단순 경로 → 경로 상에 존재하는 정점들이 모두 다른 경로
				- 사이클 → 세 개 이상의 정점을 가진 경로 중에서 시작 정점과 끝 정점이 같은 경로 {1, 3, 4,  2, 1}
				- 단순 사이클 → 시작 정점과 끝 정점을 제외하고 모든 정점이 다른 사이클 {1, 2, 3, 1}

	     - **인접행렬**adjacency matrix
			![[인접행렬 예.png|500]]

	     - **인접리스트**adjacency list
			![[인접 리스트 예.png|500]]

     - 그래프 순회: 그래프의 모든 정점을 체계적으로 방문하는 것 
	  → 최종 방문 순서는 구현 방법에 따라 달라질 수 있음
	     - **깊이 우선 탐색**depth first search
		     - 최근 방문하지 않는 인접한 하나의 정점을 우선적으로 방문
	     - **너비 우선 탐색**breadth first search
		     - 최근 방문하지 않은 인접한 모든 정점을 모두 방문함


### 알고리즘(1)

1. 기본 개념  
     - 컴퓨터 **알고리즘** → 주어진 문제에 대한 하나 이상의 결과를 생성하기 위해 모호하지 않고 간단하며 컴퓨터가 수행 가능한 일련의 유한개의 명령들을 순서적으로 구성한 것 

     - 이론적 관점에서 반드시 만족해야 할 조건: 
	     - *입출력* → 0개 이상의 외부 입력과 하나 이상의 출력이 있어야 한다
	     - *명확성* → 각 명령은 모호하지 않고 단순 명확해야 한다
	     - *유한성* → 한정된 수의 단계를 거친 후에는 반드시 종료한다
	     - *유효성*  → 모든 명령은 컴퓨터에서 실행 가능해야 한다

     - 실용적 관점에서의 추가 조건: *효율성*
    

2. 알고리즘 설계  
     - 대표적인 설계 기법:
	     - *분할정복 방법* → 순환적으로 문제를 푸는 방식
		     - 문제를 더 이상 나눌 수 없을 때까지 두 개 이상의 작은 문제로 순환적으로 분할하고, 분할된 문제들을 각각 해결한 후 이들의 해를 결합하여 원래 문제의 해를 구하는 하향식 접근 방법으로, 각 순환 호출 시마다 분할, 정복, 결합의 세 단계를 거친다. 
		     - 적용 가능한 문제 → 퀵 정렬, 합병 정렬, 이진 탐색  
	
	     - *동적 프로그래밍 방법* → 문제의 크기가 가장 작은 소문제부터 해를 구해서 테이블에 저장해 놓고 이를 이용하여 입력 크기가 보다 큰 원래의 문제를 점진적으로 만들어가는 상향식 접근 방법  
		     - 적용 가능한 문제 → 모든 정점 간의 최단 경로를 구하는 플로이드 알고리즘  


	     - *욕심쟁이 방법* → 해를 구하는 일련의 선택 과정마다 전후 단계의 선택과는 상관없이 각 단계에서 ‘가장 최선’이라고 여겨지는 국부적인 최적해를 선택해 나가면 결과적으로 전체적인 최적해를 얻을 수 있을 것이라고 희망하는 방법
		     - 거스름돈 문제 → 고객에서 돌려줄 거스름돈이 T만큼 있을 때 고객이 받을 동전의 개수를 최소로 하면서 거스름돈을 돌려주는 방법을 찾는 문제 → 단순히 동전의 액면가가 가장 큰 동전부터 차례대로 최대한 거스름돈을 만든다.  
		     - 배낭 문제(물체를 쪼갤 수 있는 경우) → 배낭의 용량을 초과하지 않는 범위에서 배낭에 들어 있는 물체의 이익의 합이 최대가 되도록 배낭에 물체를 넣는 방법을 찾는 문제 → 단위 무게당 이익이 가장 큰 물체부터 통째로 배낭에 넣고, 만약에 배낭의 남은 용량보다 물체의 무게가 큰 경우에는 물체를 쪼개서 배낭에 넣는다.  
 
3. 알고리즘 분석  
     - **정확성 분석** → 유효한 입력이 주어졌을 때 유한 시간 내에 정확한 결과를 생성하는지를 수학적으로 증명  
     - **효율성 분석** → 알고리즘 수행에 필요한 컴퓨터 자원, 즉 소요되는 메모리 공간의 크기  
       (“공간 복잡도”)와 수행에 걸리는 시간(“시간 복잡도”)을 측정  
     - **시간 복잡도** (알고리즘의 수행 시간) → 알고리즘에서 수행되는 기본적인 연산의 수행횟수의 합  
	    - 단순히 단위 연산의 개수가 아닌 입력 크기의 함수로 표현  
	    - 입력 데이터의 상태에 따라 달라지며, *일반적으로 최악의 수행 시간을 사용*  
	    - 점근성능 → 입력 크기 n이 충분히 커질 때 알고리즘의 수행 시간이 무엇에 의해 좌우되는가를 나타내는 성능 → 수행 시간이 다항식으로 표현되는 경우 입력 크기가 커짐에 따라 차수가 낮은 항들의 역할은 감소하고, 결국 계수 없이 n의 최고차항만을 이용해서 표현 → 수행 시간의 어림값이지만 수행 시간의 증가 추세 파악이 용이하여 알고리즘의 우열을 따질 때 사용  
	    - 표기법 → ① “Big-Oh” 점근적 상한 f(n)=O(g(n)), ② “Big-Omega” 점근적 하한 f(n)=Ω(g(n)), ③ “Big-Theta” 점근적 상하한 f(n)=Θ(g(n)) 
	    - 빅오 표기 간의 연산 시간의 크기 관계 
	    - → O(1) < O(logn) < O(n) < O(nlogn) < O(n2) < O(n3) < … < O(2n)
    
4. 정렬 알고리즘 (내부 정렬 vs 외부 정렬)
	- *내부 정렬* → 모든 데이터를 주기억장치에 적재한 후 정렬하는 방식  
	- *외부 정렬* → 모든 데이터를 주기억장치에 저장할 수 없는 경우, 일부 데이터만 주기억장치에 있고 나머지는 외부기억장치에 저장한 채 정렬하는 방식  

     - 비교 기반 정렬 vs 분포 기반 정렬  
		- *비교 기반 정렬* → 데이터의 키값을 직접 비교하여 정렬하는 방법
			- 선택 정렬
			- 버블 정렬
			- 삽입 정렬
			- 퀵 정렬
			- 합병 정렬  
		- *분포 기반 정렬* → 데이터의 분포 정보를 사전에 얻어서 정렬에 이용하는 방법
			- 계수 정렬
			- 기수 정렬  

     - *선택 정렬*  
	     - 주어진 데이터 중에서 가장 작은 값부터 차례대로 선택해서 나열하는 방식
		     - ① 미정렬 부분의 데이터 중에서 가장 작은 값을 선택하고
		     - ② 선택된 값과 미정렬 부분의 첫 번째 데이터와 교환 

	     - 데이터의 입력 상태에 민감하지 않고 언제나 동일한 수행 시간 → O(n2)  

     - *버블 정렬*  
	     - 왼쪽에서부터 모든 인접한 두 데이터를 차례대로 비교하여 왼쪽의 값이 더 큰 경우에는 오른쪽값과 자리바꿈을 통해 정렬하는 방법
	     - 데이터가 원하는 순서로 이미 정렬된 경우에는 O(n)을 갖고, 역순으로 정렬된 경우에는 최악의 수행 시간 O(n2)을 가짐
	     - 데이터의 교환이 많이 발생하여 선택 정렬보다 비효율적

	- *삽입 정렬*
		- 주어진 데이터를 하나씩 뽑은 후, 나열된 데이터들이 항상 정렬된 형태를 가지도록 뽑은 데이터를 바른 위치에 삽입해서 나열하는 방식
		- 미정렬 부분의 첫 번째 데이터를 꺼낸 후, 정렬된 부분에서 제자리를 찾아 삽입하는 과정을 반복
		- 주어진 데이터가 이미 정렬된 경우에는 최선의 수행 시간 O(n)을 갖고, 데이터가 역순으로 정렬된 경우에는 최악의 수행 시간 O(n2)을 가짐