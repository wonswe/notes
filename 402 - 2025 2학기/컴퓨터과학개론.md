### 컴퓨터와 자료 (1)

**컴퓨터**: 프로그램이 가능한 데이터 처리기 (programmable data processor)
- 장점: *신속*, *정확*, *자동*, *대용량*
- 데이터의 입력 (input) -> 처리 (process) -> 결과 출력 (output)

**프로그램**: 컴퓨터가 데이터를 어떻게 처리(조작)할지를 알려주는 일련의 명령어의 집합
- 컴퓨터에서 처리 가능한 작업의 유형과 연산의 집합을 결정

**컴퓨터과학이란?**
- 데이터의 획득, 표현, 처리, 저장, 통신, 접근을 위한 방법들의 실행 가능성, 구조화, 표현, 기계화에 관련된 내용을 다루는 학문 분야
- *컴퓨터*, *데이터*, *프로그램*, *알고리즘* 분야의 연구를 통해 효율적인 자료 처리를 위한 제반 기술과 방법들을 제공하기 위한 학문
- 알고리즘과 관련된 이슈를 다루는 학문 -> 컴퓨터과학의 모든 관련 분야를 “알고리즘” 중심으로 이해 가능
- 컴퓨터를 활용한 문제 해결에 대한 학문

**컴퓨터공학** - 가격 대비 성능 특성이 가장 좋은 컴퓨터 엔진을 만들기 위해 하드웨어와 소프트웨어 요소를 조립하는 방법에 중점을 둠

**컴퓨터과학** - 현재의 기술에 덜 의존적인 방식으로 주어진 문제에 대한 해결책이 효율적이고 실현 가능성에 보다 초점을 둠

컴퓨터 시스템의 **4가지 구성요소**
1. *하드웨어* - 기계를 구성하고 있는 모든 물리적 *기계장치* 및 *전자장치*
   ![[하드웨어의 구성.png|400]]
	- 핵심 장치
		1. *중앙처리장치 CPU* - Central Processing Unit
			1. 산술논리연산장치 Arithmetic and Logic Unit - 산술 연산 & 논리 연산의 수행을 통해 직접적인 데이터 처리가 이루어지는 장치
			2. 제어장치 Control Unit - 컴퓨터의 기억장치, 산술논리연산장치, 입출력장치의 동작을 제어하는 장치
		2. *기억장치* 
			1. 주기억장치 - 처리할 입력 데이터, 처리를 담당하는 프로그램, 중간 결과, 출력할 데이터
			2. 보조기억장치
		3. *입력장치* - 키보드, 마우스, 마이크, 카메라 등 [보조기억장치 (디스크)]
		4. *출력장치*  - 모니터, 프린터, 스피커 등 [보조기억장치 (디스크)]
    ![[하드웨어 요소 간의 통신.png|600]]

2. *소프트웨어* - 모든 프로그램을 총체적으로 표현하는 것
	- 컴퓨터가 데이터를 어떻게 처리할 것인가를 규정하는 명령어들의 나열
		1. **시스템 소프트웨어** -  컴퓨터 자체의 작업 관리와 특정 기능의 수행을 통해 컴퓨터의 전체적인 운영을 담당한느 프로그램 (운영체제, 컴파일러, ...)
		2. **응용 소프트웨어** - 사용자가 요구하는 작업을 직접적으로 수행하는 프로그램 (워드프로세서, 그래픽 프로그램, 웹 브라우저, ...)

3. *데이터* - 컴퓨터가 처리할 대상으로 컴퓨터 내부에서 **비트 패턴으로 변환**되어 처리되고, 적절한 **변환 과정을 다시 거쳐 출력**됨


4. *사용자*operator- 컴퓨터가 데이터를 처리하는 전반적인 과정에 다양하고 적극적인 형태로 사람이 개입이 필요

**폰 노이만 모델** - 컴퓨터의 *내부 구조*와 *처리 과정*을 정의한 모델
- 모든 컴퓨터는 폰 노이만 모델에 기반을 둠
- *4개의 서브시스템*으로 구성
	1. 산술논리연산장치
	2. 제어장치
	3. 기억장치
	4. 입출력장치
- *내장 프로그램*  stored program 방식
	- 데이터와 함께 실행될 프로그램은 *메모리에* 저장되어야 함
	- 데이터와 프로그램이 같은 메모리에 저장된다는 것은 동일한 형식 ("비트 패턴")으로 저장된다는 의미를 내포 -
	- "프로그램은 유한 개의 명령어의 나열" - 기본 명령어의 집합을 *미리* 정의하고, 이들의 유한개의 조합으로 원하는 프로그램을 구성
	- 제어장치가 메모리에서 한 번에 하나씩 명령어를 가져와서*fetch* 해석하고*decode* 산술논리연선장치가 실행함*execute*
	- 명령어들의 재사용성 good ~

### 컴퓨터와 자료 (2)

1. **데이터와 정보**  
    - I=P(D) → “*데이터 D*를 대상으로 *처리기 P*에서 처리해서 얻은 *결과가 정보 I*이다.”  
    - *데이터* → 현실 세계로부터 관찰이나 측정을 통해 단순히 얻어지는 사실이나 값  
    - *정보* → 어떤 상황에 대해 *적절한 의사결정*을 수행할 수 있게 하는 지식  
    - *데이터 처리(“정보처리”)* → 데이터를 정보로 가공하고 변환하는 일련의 과정  

     ![[데이터와 정보의 관계.png|400]]
    - 모든 데이터는 유형에 무관하게 *비트 패턴*이라는 일관된 방식으로 표현  
		=> 메모리에 저장된 데이터 유형에 맞는 해석과 처리가 필요 
		(입출력장치나 프로그램의 책임/역할)
	
    - *데이터의 표현 단위* → 비트, 바이트, KB, MB, GB, TB, PB, EB, ZB, YB  
	    - 비트 binary digit - 0 or 1
	    - 바이트 byte - 길이가 8개인 비트 패턴
		![[데이터의 표현 단위.png|600]]

    - 워드word → *컴퓨터 연산의 기본 단위가 되는 정보의 양*: 보통 32비트, 64비트  

2. **진법** - 수를 세는 방법 또는 단위
	- r진법 → 0, 1, …, (r-1)까지의 숫자만을 사용해서 수를 표현하는 방식 또는 단위  
	- *2진법*, *8진법,* *10진법*, *16진법* 간의 변환이 필요    
     ![[r진법.png|400]]
     ![[r진법표기예시.png|400]]
	- 2진수/8진수/16진수를 10진수로 변환 
	  → 각 위치에서의 숫자값과 **해당 위치에서의 가중치(자릿값)를 곱한 후**, **그 결과들을 모두 더함**  
      ![[2진수를10진수로.png|500]]
      ![[8:16진수를10진수로.png|500]]

	- **10진수를 r진수로 변환** → 정수 부분과 소수 부분을 나눠서 각각의 방법으로 변환한 후, 그 결과를 단순히 연결해서 표현함 → 정수 부분에 대해서는 나눗셈을 적용한 후 나머지를 결과로 활용, 소수 부분에 대해서는 곱셈을 적용한 후 정수 부분을 결과로 활용  
	  ![[10진수를r진수로.png|500]]
      ![[10진수를r진수로_알고리즘.png|500]]
      ![[10진수를r진수로_예시.png|500]]
      ![[10진수를r진수로_소수 부분_알고리즘.png|500]]
	  ![[10진수를r진수로_소수 부분_예1.png|500]]
	  ![[10진수를r진수로_소수 부분_예2.png|500]]

      ![[컴퓨터에서의 실수는 근사치.png|500]]
      위에서 볼 수 있듯, 컴퓨터에서 나타내는 실수는 *근사치*다 
      ![[r진수 간의 변환.png|500]]
  
	- 2진수와 8진수/16진수의 관계 → 2진수의 3자릿수 = 8진수의 1자릿수, 2진수의 4자릿수 = 16진수의 1자릿수  
    

3. **정수 표현**  
    - 정수 표현 방법의 종류
		1. *부호 없는* 정수 → 부호 비트가 없다
			- 주어진 n비트 전체를 사용해서 정수(0~2^(n-1))를 표현  
			 ![[부호없는정수.png|400]]
		2. *부호 있는* 정수 → 최상위 1비트를 부호 비트로 사용
		    1. 부호화-크기 방식 → 음의 정수는 음수에 대한 절대값으로 표현  

		    2. 1의 보수 방식 → 부호 비트 사용. 음의 정수는 양의 정수 표현에 대해 **보수**(0→1, 1→0)를 취해서 표현    ![[부호있는정수예.png]]

		    3. 2의 보수 방식 → 부호 비트 사용. 음의 정수는 1의 보수 방식의 결과에 1을 더해서 표현  
			    ![[부호있는정수예.png]]
				![[정수표현의방법비교.png]]

4. **실수 표현**  

	![[실수표현예.png|400]]
    - 과학적 표기법을 활용한 부동소수점 방식으로 표현 
    - 표현 형식 → (-1)부호×가수×2지수 → “부호(1비트)+지수(m비트)+가수(n비트)”  

    - 지수의 표현  
    - **초과표기법** → 부동소수점의 *지수 부분*만을 위한 표기 방법 → 지수를 m비트로 표현하는 경우 두 개의 매직 넘버(2m-1, 2m-1-1) 중에서 하나를 사용  
	  ![[초과표기법예.png]]

    - 지수값을 저장하는 경우 → (지수값 + 매직 넘버)를 이진수로 표현/저장  
    - 저장된 지수값을 해석하는 경우 → (지수 부분의 이진수 값 - 매직 넘버)  

	- 가수를 표현할 때 표준화된 형식이 필요 → **정규화** → *소수점 바로 왼쪽에 오직 하나의 1만 있도록 소수점의 위치를 조정* → 가수값을 저장할 때는 소수점 이하 부분만 저장  
	  ![[정규화방법.png|400]]
	- 실수 표현의 에
     ![[실수표현의예.png]]
	  ![[IEEE부동소수점표기법.png]]
5. **문자 표현**  
    - 키보드로 입력되는 문자를 *내부적으로 2진수로 변환*하여 처리하기 위해서는 문자마다 유일한 코드를 부여할 수 있는 약속된 문자 체계가 필요  
    - 대표적인 문자 체계 → *ASCII (또는 확장된 ASCII)*, *유니코드*
- ASCII → American Standard Code for Information Interchange
	- 미국표준협회 (ANSI)
	- 7비트 코드 → 128개 (2^7)의 서로 다른 문자 표현
		- 확장된 아스키 Extended ASCII → 1비트 + 7비트
		- 패러티 parity 비트로 전송 중 에러가 없었는지 확인 가능
- 유니코드
	- 세계의 모든 문자를 컴퓨터에서 일관되게 표현하고 다룰 수 있도록 설계된 표준
- 기타 코드 체계
	- EBCDIC - Extended Binary Coded Decimal Interchange Code
		- IBM 개발, 8비트 코드 → 실제 사용되는 문자 코드는 128개
	- BCD - Binary Coded Decimal
		- 4비트로 구성된 10개의 코드로 10진수를 표현하는 방식 → '8421 코드'


### 자료구조(1)

추상화와 구조화 → 자료의 추상화와 구조화가 적절히 이루어지지 못하면 소프트웨어는
- 비효율적으로 개발
- 비효율적으로 수행
- 확장성의 문제
- 유지보수에 문제
... 등 생길 수 있음

**추상화** → 공통적인 개념을 이용하여 같은 종류의 다양한 객체를 정의하는 것 (수식, 프로그램 언어 등)

**자료(데이터)추상화** → 다양항 객체를 컴퓨터에서 표현하고 활용하기 위해 필요한 *데이터의 구조에 대해서 공통의 특징만을 뽑아 정의한 것* 

1. **자료구조** → 자료 사이의 논리적 관계를 컴퓨터나 프로그램이 보다 쉽게 이해하고 다룰 수 있도록 구성한 것 → *추상화를 통해 자료의 논리적 관계를 구조화한 것*
   ![[자료구조의 종류와 관계.png|600]]
	
2. **배열array**  → 같은 자료형을 갖는 여러 개의 데이터를 *하나의 변수*로 묶어놓은 데이터의 집합체이며,  각 원소를 구분하기 위해 *인덱스*(또는 첨자)와 *데이터 값*의 쌍으로 이루어짐  
	![[1차원배열주소계산.png|600]]
	- 배열의 원소들은 연속적인 기억장소에 저장되어 *순차적으로 저장*되기 때문에 배열의 시작주소와  각 자료형의 크기를 알면 i번째 원소의 주소를 알면, 직접 접근이 가능함  
	- 물리적 주소(메모리/RAM의 주소)와 논리적 주소(개발자가 정의한 주소 like 변수)가 일치(mapping되는) 하는 유일한 자료구조
     - 다차원 배열이 저장되는 방식으로는 열 우선 순서와 행 우선 순서가 있음
		![[2차원배열.png|400]]
	    - **2차원 배열 저장 순서** 
		    - 열 우선 순서 저장 → 첫 열에 있는 각 행의 원소를 차례대로 컴퓨터 메모리에 저장하고 다음 열로 이동하여 각 행에 있는 원소를 차례대로 컴퓨터 메모리에 저장하는 방법
		    - 행 우선 순서 저장 → 첫 행에 있는 각 행의 원소를 차례대로 컴퓨터 메모리에 저장하고 다음 행으로 이동하여 각 열에 있는 원소를 차례대로 컴퓨터 메모리에 저장하는 방법
        ![[3차원배열.png|400]]
		![[희소행렬의효율적표현.png|400]]

3. **리스트**
	- 선형 리스트 (linear list) → 순서 리스트 (ordered list)라고도 함
	- 1개 이상의 원소들이 순서를 가지고 구성됨
	- A = (a1, a2, ..., ai, an)과 같이 표시하며 ai는 i번째 원소를 나타내고, an의 n은 리스트의 크기가 된다 
	- ex. 요일 리스트: (월, 화, 수, 목, 금, 토, 일)
	- ex. 전쟁 리스트: ((임진왜란, 1592), (황산벌 전투, 660))
	- 선형 리스트와 1차원 배열은 순차적인 구조를 가지고 있으므로 1차원 배열로 간단하게 표현할 수 있음
	- 삽입시 순서를 그대로 유지하면서 해야 함 & 삭제시 원소들을 한 칸 씩 앞으로 이동시켜야 함, 등 등 삽입 & 삭제 시 데이터의 이동이 잦아지므로 비효율적이다

4. **연결 리스트**  → 노드들을 연결하여 구성하는 것으로, 한 노드는 **데이터 필드**와 **링크 필드**로 구성됨  
     - *단일 연결 리스트* : 링크 필드가 하나이고, 한 방향으로만 검색이 가능함  
     - *이중 연결 리스트* : 2개의 링크 필드를 사용해서 양방향(선행 노드 방향, 후행 노드 방향)의 검색이  가능함  
     - *원형 연결 리스트* : 마지막 노드의 링크 필드가 첫 번째 노드에 연결되어, 한 방향이지만 전체 연결 & 리스트를 원형으로 연결함
    
5. **스택** → 리스트의 *한쪽 끝에서만 삽입과 삭제가 이루어지*는 *선입후출*(FILO, First-In-Last-Out) 구조  
	- 스택 언더플로 → 삭제 연산을 수행할 때 발생함
		- 스택에 데이터가 존재하지 않으면 삭제가 일어나지 않는 현상
	- 스택 오버플로 → 삽입 연산을 수핼할 때 발생함
		- 스택을 위해 할당된 저장 공간을 초과해서 더 이상 데이터를 삽입할 수 없는 현상
	- pop연산과 push 연산이 가장 중요한 연산임
    
6. **큐** → 리스트의 한쪽 끝에서는 삽입, 다른 한쪽 끝에서는 삭제가 이루어지는 *선입선출(FIFO)* 구조  
	- 오버플로 → 삽입시 발생 & 큐를 위해 할당된 저장 공간을 초과해서 더 이상 데이터를 삽입할 수 없는 현상
	- 언더플로 → 삭제시 발생 & 큐에 데이터가 존재하지 않으면 삭제가 일어나지 않는 현상
	- insert 연산과 delete 연산이 가장 중요한 연산임
	- 만원 상태 → 데이터가 큐에 삽입됨에 따라 rear 변수 값이 증가하다가 n-1이 되면 더 이상 데이터가 삽입될 수 없는 상태가 됨, but 이 경우가 반드시 큐에 n개의 항목이 가득 차 있다는 것을 의미하지는 않는다. 큐가 가득 채워진 상태를 결정하기 위한 다른 방법이 필요!


### 자료구조(2)

