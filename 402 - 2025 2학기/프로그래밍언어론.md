

BNF

### 1강 - 프로그래밍 언어 소개
서브프로그램
모듈

프로그래밍 언어의 **기본 기능**
- **작성력**: 의도를 나타낼 수 있게 하는 기능
- **가독성**: 쉽게 해독할 수 있게 하는 기능
- **실행** 가능성: 컴퓨터에서 실행될 수 있게 하는 기능
부가 기능
- **추상화**: 간략하게 추려 나타낼수 있게 하는 기능
- **모듈화**: 복잡한 대상을 나누어 구성할 수 있게 하는 기능

프로그래밍 언어의 **특성**
- **기계적**: 엄밀한 규칙에 따라 기계적으로 처리
- **구조적**: 복잡한 구조를 나타냄 (자료구조, 제어구조)
- **가변적**: 필요에 따라 바뀔 수 있다 (ex. python은 명령형 언어에서 -> 객체지향 개념 탑재)

프로그래밍 언어 스펙트럼 (고급 - 저급)

프로그래밍 언어의 구성 요소 

- 데이터: 자료를 프로그램이 처리할 수 있는 형태로 나타낸 것 (수, 문자, 문자열, 멀티미디어 데이터 등) - 이진 데이터 & 텍스트 데이터

- 연산: 데이터 처리 방법으로 연산 적용 후 새로운 데이터를 결과로 얻는다
	- 연산자: 연산을 수행하는 함수
	- 변수: 연산 결과를 저장하는 이름
	- 대입 연산: 변수에 값을 부여하는 연산

- 명령어: 특정 작업을 지시하는 단어
	- if, while 등
	- 연산의 종류
		- 원시연산: 기본적으로 제공하는 연산
		- 사용자정의연산: 사용자가 추가로 정의한 연산
		- 라이브러리: 사용자가 자주 사용할 만한 연산을 미리 정의해 둔 것

- **서브프로그램**: 전체 프로그램을 이루는 작은 코드 블록에 이름을 붙인 것
	- 서브루틴이라고 부르기도 한다
	- 분류
		- 함수: 연산 수행 결과 값을 반환하는 서브프로그램
		- 프로시저: 결과 값을 반환하지 않는 서브프로그램

- 타입: 데이터 집합 & 연산 집합을 합친 개념
	- 연산의 안정성 보장을 위해 필요
	- 분류
		- 강타입 언어
		- 약타입 언어
		- 무타입 언어

- **모듈**: 독립적인 프로그램 구성단위
	- 서브프로그램도 모듈의 일종
	- 모듈의 특징
		- 내부와 외부를 구별
		- 독자적인 이름 공간을 차지하고 관리함
		- 변수, 함수, 타입 등 프로그래밍 언어에서 제공하는 거의 모든 것을 포함하는 단위

### 2강 - 프로그래밍 언어의 발전 및 동작 원리
프로그래밍 언어의 평가 기준 중 두 가지 설명

컴퓨터 시스템의 발전
 - 아이디어: 계산 자동화를 위한 상상 속의 기계 설계 (튜링)
 - 전자식 컴퓨터: 전자 신호를 통한 계산 기계 (에니악, 콜로서스)
 - 프로그램 저장 방식의 컴퓨터: 프로그램 & 처리기를 분릐 (에드박)

운영체제의 발전
- 일괄처리 운영체제
	- 관리자 (operator)를 대신할 프로그램 등장
- 시분할 운영체제
	- 한 컴퓨터를 여러 사람이 동시에 사용
- DOS
	- IBM 컴퓨터, Apple 등 개인용 컴퓨터 (PC) 등장
- PC 환경 운영체제
	- GUI 운영체제와 Linux의 발전

1950년대 초기 프로그래밍 언어
- Fortran: 수식과 문장, 제어문의 등장
	- IBM의 존배커스가 개발
	- 과학계산용 언어 (formula translation)
![[Fortran.png]]

- Algol: 구조화 프로그래밍의 발전
	- 본래 이름: IAL (International Algebraic Language)
	- 국제 위원회 ACM-GAMM을 통해 설계된 언어
	- 알고리즘 기술 언어
![[Algol.png]]
- LISP: 초기 함수형 언어
	- MIT의 존 매카시가 설계
	- 최초의 함수형 언어
![[LISP.png]]

1960년대: 프로그래밍 언어의 발전
- Cobol: 레코드 타입의 소개
	- 미 해군에서 그레이스 호퍼가 이끄는 팀이 개발
	- 사무용 언어
![[Cobol.png]]
- PL/1: 모든 언어를 합쳐보았으나 결과적으로 너무 복잡한 언어가 됨
- BASIC: 교육용 언어로 Beginner's All-purpose Symbolic Instruction Code
- Simula: 객체지향의 등장, 시뮬레이션 언어

1970년대: 프로그래밍 언어의 단순화
- Pascal: 차세대 교육용 언어
	- 니클라우스 버트가 개발
	- 구조화 프로그래밍 지원
- C: 진정한 시스템프로그래밍 언어
	- 데니스 리치가 개발
	- Unix 개발용 시스템 프로그래밍 언어
	- Objective-C, C++, Java, C#등 다양한 언어에 지대한 영향을 끼침
- Prolog: 선언적 논리 언어 (최초의 논리 언어)
- Smalltalk: 객체지향 언어의 발전
	- 최초로 GUI, 마우스를 도입
- Ada: 안정성을 위한 대장정
	- 미 국방성 (DoD) 공모
	- 매우 복잡한 언어로 1983년에 첫 컴파일러 등장
- ML: 타입 시스템을 갖춘 현대 프로그래밍 언어
	- Meta Language의 약자
	- 강력한 정적 타입 검사, 타입 추론, 패턴 검사, 예외 처리 등
- Scheme: 간결한 LISP
	- MIT 학생들의 기초 프로그래밍 언어

1980년대
- Common Lisp
- Objective C
- C++: 객체지향 C, class 개념 도입
- Perl: 문자열 처리를 위한 언어, 정규식을 바탕으로 한 강력한 패턴 매칭 기능 포함

1990년대
- Java: 단순한 객체지향 언어
	- 임베디드 컴퓨팅 -> 웹 브라우저
	- JVM (Java Virtual Machine)
- JavaScript: 웹 프로그래밍 언어
	- Netscape
	- Elm, TypeScript등 다양한 변종 언어로 발전

1990년대 이후
- Python: 빠른 프로토타이핑 언어
	- 스크립트 언어
	- 동적 언어를 추구 (무타입 언어)
	- 다중 패러다임 언어
- Haskell: 순수 함수형 언어
	- 국제위원회가 만든 함수형 언어
	- 모나드 (monad) 탑재후 인기를 끎
	- Scala에 영향을 줌
![[컴퓨터구조.png]]
동작 원리
1. 전원을 켜면 ROM에 있는 BIOS는 하드웨어 점검 후 저장장치의 특정 코드 (부트로더)를 수행
2. 부트로더는 운영체제(OS)를 메모리로 적재하여 수행
3. CPU는 인출-해석-실행 주기를 반복하여 메모리에 적제된 프로그램의 명령어를 수행

프로그래밍 언어 구현이 필요한 이유
- 기계어
	- CPU가 이해하고 수행하는 명령어
	- 이진수 형태의 명령어를 사람이 이해하는 것은 매우 난해하다
- 어셈블리어
	- 기계어에 거의 일대일 대응하는 형태의 기호 언어
	- CPU에 종속적 -> 이식성이 거의 없음
- 고급 프로그래밍 언어
	- 사람에 가까운 표현으로 프로그램을 나타낸다
	- 특정 기계에 종속적이지 않음
	- 프로그램을 CPU가 알아듣는 기계어로 표현해주어야 함
	- 소스 프로그램 (우리가 작성한 고급 언어)과 목적 프로그램(기계언어)의 간극을 메꾸어야 함
![[언어구현방법.png]]

**인터프리터 & 컴파일러의 차이점**

두 가지 방법
- 소스 프로그램을 **컴파일러**를 이용해서 목적 프로그램으로 변환
- 소스 프로그램을 **인터프리터**로 해석하여 컴퓨터에게 실행 시킨다

인터프리터
- 고수준의 명령을 하나씩 해석하여 실행하는 프로그램이다
- CPU가 기계어 명령어를 메모리에서 하나씩 가져와서 실행하는 실행 주기와 비슷함

컴파일러
- 프로그램 전체를 CPU가 수행할 수 있는 형태로 바꾼 뒤 CPU가 프로그램을 실행한다
- 인터프리터가 명령어를 하나씩 해석/실행하는 과정을 미리 모두 수행하여 시간이 단축되고 효율적이라고 할 수 있다
- 상용 프로그램은 컴파일 방식을 통해 번역된 후 판매된다

하이브리드 구현
- 인터프리터 & 컴파일러 방식을 조합
- 중간코드까지 컴파일한 후 인터프리터를 통해 해석![[하이브리드구현.png]]
- 중간코드: 일반화된 기계어라고 생각하면 편하다
- 이식성이 좋다

프로그래밍 언어의 요구사항
- 표현 풍부성 (expressiveness)
	- 사용자의 아이디어를 표현할 수 있어야 한다
- 유지 보수성 (maintainability)
	- 변화에 쉽게 대처할 수 있어야 한다
- 실행 가능성 (executability)
	- 컴퓨터에서 실행 가능해야 한다
- 규칙성 (regularity)
	- 언어의 기능이 잘 조합될 수 있어야 한다
	- 일반성, 직교성, 일관성
- 추상화 지원 (support of abstraction)
	- 실세계의 대상을 추상화하여 나타낼 수 있고 이를 대상으로 어떤 연산을 수행할 수 있어야 함
	- 데이터 추상화, 제어 추상화, 추상 데이터 타입 정의
- 복잡도 제어 (complexity control)
	- 복잡한 대상 및 처리 방법을 제어할 수 있어야 함
	- 캡슐화, 모듈화

**프로그래밍 언어의 평가 기준**
![[프로그래밍언어의평가기준.png]]
![[평가기준사이의절충.png]]

### 3강 - 프로그래밍 언어 패러다임

1. **프로그램을 작성하는 전형적인 방식**을 프로그래밍 패러다임이라고 한다.
2. **명령형 프로그래밍 패러다임**에서 프로그램은 특정 작업을 수행하기 위해 명령어가 나열된 것이다. 컴퓨터 하드웨어의 속성을 그대로 반영한 형태의 패러다임이다.
		(+) 프로그램을 쉽게 이해할 수 있다
		(-) 복잡한 프로그램에 경우 효과적으로 다루지 못한다
3. **절차형 프로그래밍 패러다임**은 문제를 해결하기 위한 절차를 서브루틴 단위의 절차로 구현하는 방식의 패러다임으로, 프로그램을 절차의 집합으로 간주한다.
		(+) 재귀호출을 사용하여 프로시저를 간단하게 정의
4. **함수형 프로그래밍 패러다임**에서는 데이터를 값으로 간주하고, 주어진 데이터로부터 새로운 값을 생성하는 함수에 초점을 맞추어 프로그램을 작성한다.
	- 프로그램 수행 -> 원하는 값을 구하는 것
	- 원하는 값은 초깃값에 함수를 반복적으로 적용함으로써 구할 수 있다
	- 데이터 -> 값
	- 명령어 -> 함수
	- 명령어가 데이터를 바꿀 수 없다
	- 대입문 & 반복문 없음
	- 함수 자체도 값으로 취급 가능: 함수를 다루는 함수 -> 고계함수
5. **논리 프로그래밍 패러다임**에서는 문제의 조건을 논리식(규칙)으로 표현하고 이 식을 바탕으로 어떤 사실을 입증해 나가는 방식으로 프로그램을 수행한다. 논리 프로그래밍 패러다임은 선언적 프로그래밍 패러다임의 일종이다.
6. **객체지향 프로그래밍 패러다임**은 데이터와 관련 연산을 합쳐 객체로 모형화하고, 객체 사이의 상호작용을 통해 프로그램을 수행하는 프로그래밍 패러다임이다.
	- 프로그램: 서로 통신할 수 있는 객체의 집합
	- 소프트웨어 재사용을 통해 빠른 개발을 지원
	- **객체의 개념**:
		- 상태를 유지하며 외부의 요청에 반응하는 데이터
		- 상태 - 필드 (멤버변수), 반응 - 메소드 (멤버 함수)
		- 상태는 외부에 숨기고 (내부 데이터는 건드리지 못하게) 메소드는 외부에 공개
7. 프로그래밍 패러다임의 변화 배경으로는 **응용 도메인의 변화, 프로그램 구성 방식의 변화, 계산 모델의 변화 등**을 들 수 있다.
8. 하나의 프로그래밍 언어가 **한 패러다임만 지원하는 것은 아니다**.
9. **구조화 프로그래밍**은 goto 논란으로부터 촉발되었는데 goto 없이 프로그램을 작성하는 패러다임이다.
	- 블록과 서브루틴을 이용
	- 구조화된 제어문을 사용
	- 현재 우리가 사용하는 대부분의 언어는 **블록 구조** 언어임
	- ![[구조화프로그래밍C.png|300]]
10. 다양한 프로그래밍 패러다임은 서로 배타적이라기보다 **상호 보완적인 것으로 보는 것이 바람직**하다.

프로그래밍 패러다임 변화의 배경
- 응용 도메인의 변화
	- 요구 사항의 변화 (계산 분야 -> 다양한 응용 분야)
- 프로그램 구성 방식의 변화
	- 명령어 나열 -> 존재하는 모듈의 조합
- 계산 모델의 변화
	- 튜링기계모델 -> 새로운 방식의 계산 모델


**프로그래밍 패러다임**: 프로그램을 작성하는 방식이나 스타일
**프로그래밍 언어 패러다임**:
- 해당 프로그래밍 언어가 지원하는 프로그래밍 패러다임
- 일반적으로 프로그래밍 언어는 여러 프로그래밍 패러다임을 지원한다

### 4강 - 구문론과 의미론

**구문론** (syntax): 문장의 **올바른 형태**를 정의
- 표면적인 구조를 정의
- 프로그램을 어떤 형태로 작성해야 하는지를 기술

**의미론** (semantics): 올바른 형태의 문장이 나타내는 **의미**를 정의
- 프로그램의 내용적인 효과를 정의
- 프로그램 실행 시 어떤 일이 일어나는지 그 의미를 기술

	ex. 나는 너를 사랑한다
	**구문**: 주어 + 목적어 + 서술어
	**의미**: 화자가 청자를 몹시 아끼고 귀중히 여긴다
	
	ex. I love you
	**구문**: 주어 + 동사 + 목적어
	**의미**: 화자가 청자를 몹시 아끼고 귀중히 여긴다

프로그래밍 언어의 형식적 정의
- 명확한 **구문**과 **의미**를 정의하는 것을 통해서 **명확한 사용체계**를 제공한다
- 켬퓨터: 프로그램 해석의 *모호함 제거*
- 작성자: 프로그램의 *동작 예측 가능*

프로그램의 구조
- **문자**: 영어, 알파벳, 아라비아 숫자, 특수 기호 등
- **어휘 (토큰)**: 문자의 나열, 최소한의 의미를 갖는 단어
- **구문**: 프로그램을 작성하는 *규칙*, *토큰을* 모아 프로그램을 구성

프로그램의 의미: 프로그램을 통해 발생하는 현상
![[프로그램의 의미.png|400]]

**<구문의 표현>**
구문론
- 프로그램의 표면적인 구조를 정의
- 정의된 구문을 통해 모든 정상적인 프로그램을 도출 가능
- 작성된 프로그램이 정의된 구문에 맞는 프로그램인지 확인 가능 
- **명확한 표현을 위해 문법을 활용**
- **일반적으로 프로그래밍 언어에서는 *문맥 자유 문법*을 이용**

	문맥 자유 문법 (CFG: Context-Free Grammar)
	![[문맥자유문법.png|400]]
	![[Screenshot 2025-10-01 at 5.16.04 PM.png|400]]

**<문맥 자유 문법의 다양한 표현 방법>**
아래 세 가지 표현법은 서로 변환이 가능하다
- BNF ↔️ EBNF
- EBNF ↔️ 구문 도표
- 구문 도표 ↔️ BNF

**BNF** (Backus-Naur Form)
- Algol의 구문을 정의하기 위해 사용된 표현법
![[BNF기호.png|400]]
![[BNF구문의표현.png|400]]
![[BNF구문예시.png|400]]

**EBNF** (Extended Backus-Naur Form)
- BNF에 추가적인 메타 기호를 사용하여 규칙을 보다 간결하게 표현
![[EBNF기호.png|400]]
![[EBNFvsBNF예시.png|400]]
![[Screenshot 2025-10-01 at 5.32.48 PM.png|400]]
![[EBNFvsBNF (한정된 범위 택일).png|400]]
![[EBNF단말기호묶음.png|400]]

**구문도표** (syntax diagram)
- 초기 Pascal의 사용자 설명서에 사용된 표기법
![[구문도표.png|400]]
![[구문도표예시.png|400]]
![[구문도표예시의 EBNF식 표현.png|400]]

![[구문도표 수식 예시.png|400]]
![[구문도표 수식 예시의 EBNF식 표현.png|400]]

![[구문도표 unsigned int 예시.png|400]]
![[구문도표 unsigned int 예시의 EBNF식 표현.png|400]]

**<의미의 표현>**
의미론
- 프로그램의 내용적인 효과를 정의
- 프로그램 실행 시 어떤 일이 일어나는지 그 의미를 기술
- 구문으로 표현하기 어려운 제약사항을 기술하기도 함
- **일반적으로 자연어 문장으로 표현하나 명확성이 부족**
- **의미를 엄밀히 표현하기 위한 다양한 기법이 개발됨 (형식 의미론)**

형식 의미론
- **정적 의미론**
	- 수행하기 전 의미가 맞는지 파악하는 방법
	- 주로 *타입 검사* 수행에 활용
	- 대표적인 표현 방법: 
		- *속성 문법*: 각 비단말 기호마다 타입 속성이 있다고 가정하여 이에 대한 규칙을 정의			![[속성문법.png|400]]

- **동적 의미론**: 수행 시 나타나게 될 의미를 표현하는 방법
	- 대표적인 표현 방법: 
		- *기능적* 의미론: 추상기계의 상태를 바꾸는 것으로 수행 의미를 표현
			- 어떤 명령어가 수행되면 메모리 상태가 어떻게 되는지를 의미론적으로 정의
			- ![[동적-기능적의미론 예시.png|400]]
		- *표기적* 의미론: 각 구문 요소를 수학적 표기에 대응시켜 수행 의미를 표현
			- 의미 함수: 대응시키는 함수
			- ![[동적-표기적의미론 예시.png|400]]
		- *공리적* 의미론: 프로그램의 효과로 수행 의미를 표현
			- 프로그램의 효과: 프로그램S가 실행됨으로써 사전조건 P를 사후 조건 Q로 변화시킴. {P} S {Q}
			- 공리 체계를 이용함으로써 주변 상황에 대응하는 논리식을 정확히 구할 수 있음
			- 대입문의 효과 공리 {Q[x->E]}  x = E; {Q}
			- ![[동적-공리적의미론 예시.png|400]]

의미론의 한계 및 효과
![[의미론의 한계 및 효과.png|400]]


