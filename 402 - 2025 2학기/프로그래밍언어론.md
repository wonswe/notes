

BNF

### 1강 - 프로그래밍 언어 소개
서브프로그램
모듈

프로그래밍 언어의 **기본 기능**
- **작성력**: 의도를 나타낼 수 있게 하는 기능
- **가독성**: 쉽게 해독할 수 있게 하는 기능
- **실행** 가능성: 컴퓨터에서 실행될 수 있게 하는 기능
부가 기능
- **추상화**: 간략하게 추려 나타낼수 있게 하는 기능
- **모듈화**: 복잡한 대상을 나누어 구성할 수 있게 하는 기능

프로그래밍 언어의 **특성**
- **기계적**: 엄밀한 규칙에 따라 기계적으로 처리
- **구조적**: 복잡한 구조를 나타냄 (자료구조, 제어구조)
- **가변적**: 필요에 따라 바뀔 수 있다 (ex. python은 명령형 언어에서 -> 객체지향 개념 탑재)

프로그래밍 언어 스펙트럼 (고급 - 저급)

프로그래밍 언어의 구성 요소 

- 데이터: 자료를 프로그램이 처리할 수 있는 형태로 나타낸 것 (수, 문자, 문자열, 멀티미디어 데이터 등) - 이진 데이터 & 텍스트 데이터

- 연산: 데이터 처리 방법으로 연산 적용 후 새로운 데이터를 결과로 얻는다
	- 연산자: 연산을 수행하는 함수
	- 변수: 연산 결과를 저장하는 이름
	- 대입 연산: 변수에 값을 부여하는 연산

- 명령어: 특정 작업을 지시하는 단어
	- if, while 등
	- 연산의 종류
		- 원시연산: 기본적으로 제공하는 연산
		- 사용자정의연산: 사용자가 추가로 정의한 연산
		- 라이브러리: 사용자가 자주 사용할 만한 연산을 미리 정의해 둔 것

- **서브프로그램**: 전체 프로그램을 이루는 작은 코드 블록에 이름을 붙인 것
	- 서브루틴이라고 부르기도 한다
	- 분류
		- 함수: 연산 수행 결과 값을 반환하는 서브프로그램
		- 프로시저: 결과 값을 반환하지 않는 서브프로그램

- 타입: 데이터 집합 & 연산 집합을 합친 개념
	- 연산의 안정성 보장을 위해 필요
	- 분류
		- 강타입 언어
		- 약타입 언어
		- 무타입 언어

- **모듈**: 독립적인 프로그램 구성단위
	- 서브프로그램도 모듈의 일종
	- 모듈의 특징
		- 내부와 외부를 구별
		- 독자적인 이름 공간을 차지하고 관리함
		- 변수, 함수, 타입 등 프로그래밍 언어에서 제공하는 거의 모든 것을 포함하는 단위

### 2강 - 프로그래밍 언어의 발전 및 동작 원리
프로그래밍 언어의 평가 기준 중 두 가지 설명

컴퓨터 시스템의 발전
 - 아이디어: 계산 자동화를 위한 상상 속의 기계 설계 (튜링)
 - 전자식 컴퓨터: 전자 신호를 통한 계산 기계 (에니악, 콜로서스)
 - 프로그램 저장 방식의 컴퓨터: 프로그램 & 처리기를 분릐 (에드박)

운영체제의 발전
- 일괄처리 운영체제
	- 관리자 (operator)를 대신할 프로그램 등장
- 시분할 운영체제
	- 한 컴퓨터를 여러 사람이 동시에 사용
- DOS
	- IBM 컴퓨터, Apple 등 개인용 컴퓨터 (PC) 등장
- PC 환경 운영체제
	- GUI 운영체제와 Linux의 발전

1950년대 초기 프로그래밍 언어
- Fortran: 수식과 문장, 제어문의 등장
	- IBM의 존배커스가 개발
	- 과학계산용 언어 (formula translation)
![[Fortran.png]]

- Algol: 구조화 프로그래밍의 발전
	- 본래 이름: IAL (International Algebraic Language)
	- 국제 위원회 ACM-GAMM을 통해 설계된 언어
	- 알고리즘 기술 언어
![[Algol.png]]
- LISP: 초기 함수형 언어
	- MIT의 존 매카시가 설계
	- 최초의 함수형 언어
![[LISP.png]]

1960년대: 프로그래밍 언어의 발전
- Cobol: 레코드 타입의 소개
	- 미 해군에서 그레이스 호퍼가 이끄는 팀이 개발
	- 사무용 언어
![[Cobol.png]]
- PL/1: 모든 언어를 합쳐보았으나 결과적으로 너무 복잡한 언어가 됨
- BASIC: 교육용 언어로 Beginner's All-purpose Symbolic Instruction Code
- Simula: 객체지향의 등장, 시뮬레이션 언어

1970년대: 프로그래밍 언어의 단순화
- Pascal: 차세대 교육용 언어
	- 니클라우스 버트가 개발
	- 구조화 프로그래밍 지원
- C: 진정한 시스템프로그래밍 언어
	- 데니스 리치가 개발
	- Unix 개발용 시스템 프로그래밍 언어
	- Objective-C, C++, Java, C#등 다양한 언어에 지대한 영향을 끼침
- Prolog: 선언적 논리 언어 (최초의 논리 언어)
- Smalltalk: 객체지향 언어의 발전
	- 최초로 GUI, 마우스를 도입
- Ada: 안정성을 위한 대장정
	- 미 국방성 (DoD) 공모
	- 매우 복잡한 언어로 1983년에 첫 컴파일러 등장
- ML: 타입 시스템을 갖춘 현대 프로그래밍 언어
	- Meta Language의 약자
	- 강력한 정적 타입 검사, 타입 추론, 패턴 검사, 예외 처리 등
- Scheme: 간결한 LISP
	- MIT 학생들의 기초 프로그래밍 언어

1980년대
- Common Lisp
- Objective C
- C++: 객체지향 C, class 개념 도입
- Perl: 문자열 처리를 위한 언어, 정규식을 바탕으로 한 강력한 패턴 매칭 기능 포함

1990년대
- Java: 단순한 객체지향 언어
	- 임베디드 컴퓨팅 -> 웹 브라우저
	- JVM (Java Virtual Machine)
- JavaScript: 웹 프로그래밍 언어
	- Netscape
	- Elm, TypeScript등 다양한 변종 언어로 발전

1990년대 이후
- Python: 빠른 프로토타이핑 언어
	- 스크립트 언어
	- 동적 언어를 추구 (무타입 언어)
	- 다중 패러다임 언어
- Haskell: 순수 함수형 언어
	- 국제위원회가 만든 함수형 언어
	- 모나드 (monad) 탑재후 인기를 끎
	- Scala에 영향을 줌
![[컴퓨터구조.png]]
동작 원리
1. 전원을 켜면 ROM에 있는 BIOS는 하드웨어 점검 후 저장장치의 특정 코드 (부트로더)를 수행
2. 부트로더는 운영체제(OS)를 메모리로 적재하여 수행
3. CPU는 인출-해석-실행 주기를 반복하여 메모리에 적제된 프로그램의 명령어를 수행

프로그래밍 언어 구현이 필요한 이유
- 기계어
	- CPU가 이해하고 수행하는 명령어
	- 이진수 형태의 명령어를 사람이 이해하는 것은 매우 난해하다
- 어셈블리어
	- 기계어에 거의 일대일 대응하는 형태의 기호 언어
	- CPU에 종속적 -> 이식성이 거의 없음
- 고급 프로그래밍 언어
	- 사람에 가까운 표현으로 프로그램을 나타낸다
	- 특정 기계에 종속적이지 않음
	- 프로그램을 CPU가 알아듣는 기계어로 표현해주어야 함
	- 소스 프로그램 (우리가 작성한 고급 언어)과 목적 프로그램(기계언어)의 간극을 메꾸어야 함
![[언어구현방법.png]]

**인터프리터 & 컴파일러의 차이점**

두 가지 방법
- 소스 프로그램을 **컴파일러**를 이용해서 목적 프로그램으로 변환
- 소스 프로그램을 **인터프리터**로 해석하여 컴퓨터에게 실행 시킨다

인터프리터
- 고수준의 명령을 하나씩 해석하여 실행하는 프로그램이다
- CPU가 기계어 명령어를 메모리에서 하나씩 가져와서 실행하는 실행 주기와 비슷함

컴파일러
- 프로그램 전체를 CPU가 수행할 수 있는 형태로 바꾼 뒤 CPU가 프로그램을 실행한다
- 인터프리터가 명령어를 하나씩 해석/실행하는 과정을 미리 모두 수행하여 시간이 단축되고 효율적이라고 할 수 있다
- 상용 프로그램은 컴파일 방식을 통해 번역된 후 판매된다

하이브리드 구현
- 인터프리터 & 컴파일러 방식을 조합
- 중간코드까지 컴파일한 후 인터프리터를 통해 해석![[하이브리드구현.png]]
- 중간코드: 일반화된 기계어라고 생각하면 편하다
- 이식성이 좋다

프로그래밍 언어의 요구사항
- 표현 풍부성 (expressiveness)
	- 사용자의 아이디어를 표현할 수 있어야 한다
- 유지 보수성 (maintainability)
	- 변화에 쉽게 대처할 수 있어야 한다
- 실행 가능성 (executability)
	- 컴퓨터에서 실행 가능해야 한다
- 규칙성 (regularity)
	- 언어의 기능이 잘 조합될 수 있어야 한다
	- 일반성, 직교성, 일관성
- 추상화 지원 (support of abstraction)
	- 실세계의 대상을 추상화하여 나타낼 수 있고 이를 대상으로 어떤 연산을 수행할 수 있어야 함
	- 데이터 추상화, 제어 추상화, 추상 데이터 타입 정의
- 복잡도 제어 (complexity control)
	- 복잡한 대상 및 처리 방법을 제어할 수 있어야 함
	- 캡슐화, 모듈화

**프로그래밍 언어의 평가 기준**
![[프로그래밍언어의평가기준.png]]
![[평가기준사이의절충.png]]

### 3강 - 프로그래밍 언어 패러다임

1. **프로그램을 작성하는 전형적인 방식**을 프로그래밍 패러다임이라고 한다.
2. **명령형 프로그래밍 패러다임**에서 프로그램은 특정 작업을 수행하기 위해 명령어가 나열된 것이다. 컴퓨터 하드웨어의 속성을 그대로 반영한 형태의 패러다임이다.
3. **절차형 프로그래밍 패러다임**은 문제를 해결하기 위한 절차를 서브루틴 단위의 절차로 구현하는 방식의 패러다임으로, 프로그램을 절차의 집합으로 간주한다.
4. **함수형 프로그래밍 패러다임**에서는 데이터를 값으로 간주하고, 주어진 데이터로부터 새로운 값을 생성하는 함수에 초점을 맞추어 프로그램을 작성한다.
5. **논리 프로그래밍 패러다임**에서는 문제의 조건을 논리식(규칙)으로 표현하고 이 식을 바탕으로 어떤 사실을 입증해 나가는 방식으로 프로그램을 수행한다. 논리 프로그래밍 패러다임은 선언적 프로그래밍 패러다임의 일종이다.
6. **객체지향 프로그래밍 패러다임**은 데이터와 관련 연산을 합쳐 객체로 모형화하고, 객체 사이의 상호작용을 통해 프로그램을 수행하는 프로그래밍 패러다임이다.
7. 프로그래밍 패러다임의 변화 배경으로는 **응용 도메인의 변화, 프로그램 구성 방식의 변화, 계산 모델의 변화 등**을 들 수 있다.
8. 하나의 프로그래밍 언어가 **한 패러다임만 지원하는 것은 아니다**.
9. **구조화 프로그래밍**은 goto 논란으로부터 촉발되었는데 goto 없이 프로그램을 작성하는 패러다임이다.
10. 다양한 프로그래밍 패러다임은 서로 배타적이라기보다 **상호 보완적인 것으로 보는 것이 바람직**하다.

프로그래밍 패러다임 변화의 배경
- 응용 도메인의 변화
	- 요구 사항의 변화 (계산 분야 -> 다양한 응용 분야)
- 프로그램 구성 방식의 변화
	- 명령어 나열 -> 존재하는 모듈의 조합
- 계산 모델의 변화
	- 튜링기계모델 -> 새로운 방식의 계산 모델